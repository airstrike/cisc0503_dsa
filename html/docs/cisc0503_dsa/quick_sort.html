<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cisc0503_dsa.quick_sort API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cisc0503_dsa.quick_sort</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
IS_IDLE = &#34;idlelib&#34; in sys.modules

def quickSort(arr, simple=False, verbose=False):
    &#34;&#34;&#34;
    The main function to sort an array using QuickSort algorithm.
    Optionally uses a simple partitioning scheme.
    &#34;&#34;&#34;
    if simple:
        partition_fn = partitionSimple
    else:
        partition_fn = partition

    _quickSort(arr, 0, len(arr) - 1, partition_fn, verbose)
    return arr

def _quickSort(arr, low, high, partition_fn, verbose):
    &#34;&#34;&#34;
    The recursive function that implements the QuickSort algorithm.
    &#34;&#34;&#34;
    if low &lt; high:
        # Find the partitioning index
        pivot_index = partition_fn(arr, low, high, verbose)

        # Separately sort elements before and after partition
        _quickSort(arr, low, pivot_index - 1, partition_fn, verbose)
        _quickSort(arr, pivot_index + 1, high, partition_fn, verbose)

def medianOfThree(arr, low, high):
    &#34;&#34;&#34;
    Helper function to find the median of three values in the array.
    The values are the first, middle, and last element of the array segment.
    &#34;&#34;&#34;
    mid = (low + high) // 2
    # Sort these elements using simple comparison
    if arr[low] &gt; arr[mid]:
        arr[low], arr[mid] = arr[mid], arr[low]
    if arr[mid] &gt; arr[high]:
        arr[mid], arr[high] = arr[high], arr[mid]
    if arr[low] &gt; arr[mid]:
        arr[low], arr[mid] = arr[mid], arr[low]
    # Now, the median is at the middle position
    return mid

def partition(arr, low, high, verbose=False):
    &#34;&#34;&#34;
    This function selects the median of the first, middle, and last elements as the pivot.
    It then places the pivot element at its correct position in the sorted array, and
    positions all smaller elements to the left of the pivot and all greater elements to the right.
    &#34;&#34;&#34;
    # Get the index of the median of three
    median_index = medianOfThree(arr, low, high)
    if verbose:
        n = max(len(str(x)) for x in arr)
        prefix = f&#34; sorting from index {low:&gt;{n}} to {high:&gt;{n}}, pivot @ {median_index:&gt;{n}}&#34;
        print(f&#34;{prefix}: {formatDisplay(arr, low, high, median_index, n)}&#34;)
    # Swap median with high to use it as pivot
    arr[median_index], arr[high] = arr[high], arr[median_index]

    pivot = arr[high]  # pivot
    i = low - 1       # Index of smaller element

    for j in range(low, high):
        # If current element is smaller than or equal to pivot
        if arr[j] &lt;= pivot:
            i = i + 1
            arr[i], arr[j] = arr[j], arr[i]

    # Swap the pivot element with the element at i+1
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

def partitionSimple(arr, low, high, verbose=False):
    &#34;&#34;&#34;
    This function takes the first element as pivot, places the pivot element at its
    correct position in sorted array, and places all smaller to left of pivot and
    all greater elements to right of pivot.
    &#34;&#34;&#34;
    pivot = arr[low]  # pivot
    i = low + 1       # Index of smaller element

    if verbose:
        n = max(len(str(x)) for x in arr)
        prefix = f&#34; sorting from index {low:&gt;{n}} to {high:&gt;{n}}, pivot @ {low:&gt;{n}}&#34;
        print(f&#34;{prefix}: {formatDisplay(arr, low, high, low, n)}&#34;)

    for j in range(low + 1, high + 1):
        # If current element is smaller than or equal to pivot
        if arr[j] &lt;= pivot:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1

    # Swap the pivot element with the element at i-1
    arr[low], arr[i - 1] = arr[i - 1], arr[low]
    return i - 1

def formatDisplay(arr, low, high, pivotIndex, n):
    list_display = &#34;&#34;
    pivot = False
    if not IS_IDLE:
        for i in range(len(arr)):
            if i &gt;= low and i &lt;= high:
                # green
                color = f&#34;\033[32m&#34;
            else:
                # no color
                color = f&#34;\033[0m&#34;
            pivot = i == pivotIndex
            element = arr[i]
            if pivot:
                element = f&#34;⟨{element:&gt;{n}}⟩&#34;
            else:
                element = f&#34; {element:&gt;{n}} &#34;
            display = f&#34;{color}{element}&#34;
            display += &#34;\033[0m&#34;
            list_display += display
    else: # pragma: no cover
        # IDLE doesn&#39;t support colors, so instead we&#39;ll bracket the part
        # of the array that is being sorted with [ and ], and also bracket the part that
        # isn&#39;t being sorted with ( and ).
        size = len(arr)
        for i in range(size):
            prefix, suffix = &#34;&#34;, &#34;&#34;
            if i == low:
                prefix = &#34;[&#34;
            else:
                prefix = &#34; &#34;
            if i == high:
                suffix = &#34;]&#34;
            else:
                suffix = &#34; &#34;
            if i == high+1:
                prefix = &#34; &#34; # (
            if i == size-1 and i != high:
                suffix = &#34; &#34; # )
            pivot = i == pivotIndex
            element = arr[i]
            if pivot:
                display = f&#34;{prefix}⟨{element:&gt;{n}}⟩{suffix}&#34;
            else:
                display = f&#34;{prefix} {element:&gt;{n}} {suffix}&#34;
            list_display += f&#34;{display}&#34;

    return list_display

def quickSortIterative(arr, simple=False, verbose=False):
    # Choose the partition function based on the &#39;simple&#39; flag
    fn = partitionSimple if simple else partition

    # Stack for storing the start and end indices of the sub-arrays
    size = len(arr)
    stack = [(0, size - 1)]

    # Process each sub-array from the stack
    while stack:
        start, end = stack.pop()
        if start &lt; end:
            pivotIndex = fn(arr, start, end, verbose)

            # Push sub-arrays to the stack
            stack.append((start, pivotIndex - 1))
            stack.append((pivotIndex + 1, end))

    return arr</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cisc0503_dsa.quick_sort.formatDisplay"><code class="name flex">
<span>def <span class="ident">formatDisplay</span></span>(<span>arr, low, high, pivotIndex, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formatDisplay(arr, low, high, pivotIndex, n):
    list_display = &#34;&#34;
    pivot = False
    if not IS_IDLE:
        for i in range(len(arr)):
            if i &gt;= low and i &lt;= high:
                # green
                color = f&#34;\033[32m&#34;
            else:
                # no color
                color = f&#34;\033[0m&#34;
            pivot = i == pivotIndex
            element = arr[i]
            if pivot:
                element = f&#34;⟨{element:&gt;{n}}⟩&#34;
            else:
                element = f&#34; {element:&gt;{n}} &#34;
            display = f&#34;{color}{element}&#34;
            display += &#34;\033[0m&#34;
            list_display += display
    else: # pragma: no cover
        # IDLE doesn&#39;t support colors, so instead we&#39;ll bracket the part
        # of the array that is being sorted with [ and ], and also bracket the part that
        # isn&#39;t being sorted with ( and ).
        size = len(arr)
        for i in range(size):
            prefix, suffix = &#34;&#34;, &#34;&#34;
            if i == low:
                prefix = &#34;[&#34;
            else:
                prefix = &#34; &#34;
            if i == high:
                suffix = &#34;]&#34;
            else:
                suffix = &#34; &#34;
            if i == high+1:
                prefix = &#34; &#34; # (
            if i == size-1 and i != high:
                suffix = &#34; &#34; # )
            pivot = i == pivotIndex
            element = arr[i]
            if pivot:
                display = f&#34;{prefix}⟨{element:&gt;{n}}⟩{suffix}&#34;
            else:
                display = f&#34;{prefix} {element:&gt;{n}} {suffix}&#34;
            list_display += f&#34;{display}&#34;

    return list_display</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.quick_sort.medianOfThree"><code class="name flex">
<span>def <span class="ident">medianOfThree</span></span>(<span>arr, low, high)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to find the median of three values in the array.
The values are the first, middle, and last element of the array segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def medianOfThree(arr, low, high):
    &#34;&#34;&#34;
    Helper function to find the median of three values in the array.
    The values are the first, middle, and last element of the array segment.
    &#34;&#34;&#34;
    mid = (low + high) // 2
    # Sort these elements using simple comparison
    if arr[low] &gt; arr[mid]:
        arr[low], arr[mid] = arr[mid], arr[low]
    if arr[mid] &gt; arr[high]:
        arr[mid], arr[high] = arr[high], arr[mid]
    if arr[low] &gt; arr[mid]:
        arr[low], arr[mid] = arr[mid], arr[low]
    # Now, the median is at the middle position
    return mid</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.quick_sort.partition"><code class="name flex">
<span>def <span class="ident">partition</span></span>(<span>arr, low, high, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This function selects the median of the first, middle, and last elements as the pivot.
It then places the pivot element at its correct position in the sorted array, and
positions all smaller elements to the left of the pivot and all greater elements to the right.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partition(arr, low, high, verbose=False):
    &#34;&#34;&#34;
    This function selects the median of the first, middle, and last elements as the pivot.
    It then places the pivot element at its correct position in the sorted array, and
    positions all smaller elements to the left of the pivot and all greater elements to the right.
    &#34;&#34;&#34;
    # Get the index of the median of three
    median_index = medianOfThree(arr, low, high)
    if verbose:
        n = max(len(str(x)) for x in arr)
        prefix = f&#34; sorting from index {low:&gt;{n}} to {high:&gt;{n}}, pivot @ {median_index:&gt;{n}}&#34;
        print(f&#34;{prefix}: {formatDisplay(arr, low, high, median_index, n)}&#34;)
    # Swap median with high to use it as pivot
    arr[median_index], arr[high] = arr[high], arr[median_index]

    pivot = arr[high]  # pivot
    i = low - 1       # Index of smaller element

    for j in range(low, high):
        # If current element is smaller than or equal to pivot
        if arr[j] &lt;= pivot:
            i = i + 1
            arr[i], arr[j] = arr[j], arr[i]

    # Swap the pivot element with the element at i+1
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.quick_sort.partitionSimple"><code class="name flex">
<span>def <span class="ident">partitionSimple</span></span>(<span>arr, low, high, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This function takes the first element as pivot, places the pivot element at its
correct position in sorted array, and places all smaller to left of pivot and
all greater elements to right of pivot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partitionSimple(arr, low, high, verbose=False):
    &#34;&#34;&#34;
    This function takes the first element as pivot, places the pivot element at its
    correct position in sorted array, and places all smaller to left of pivot and
    all greater elements to right of pivot.
    &#34;&#34;&#34;
    pivot = arr[low]  # pivot
    i = low + 1       # Index of smaller element

    if verbose:
        n = max(len(str(x)) for x in arr)
        prefix = f&#34; sorting from index {low:&gt;{n}} to {high:&gt;{n}}, pivot @ {low:&gt;{n}}&#34;
        print(f&#34;{prefix}: {formatDisplay(arr, low, high, low, n)}&#34;)

    for j in range(low + 1, high + 1):
        # If current element is smaller than or equal to pivot
        if arr[j] &lt;= pivot:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1

    # Swap the pivot element with the element at i-1
    arr[low], arr[i - 1] = arr[i - 1], arr[low]
    return i - 1</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.quick_sort.quickSort"><code class="name flex">
<span>def <span class="ident">quickSort</span></span>(<span>arr, simple=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The main function to sort an array using QuickSort algorithm.
Optionally uses a simple partitioning scheme.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quickSort(arr, simple=False, verbose=False):
    &#34;&#34;&#34;
    The main function to sort an array using QuickSort algorithm.
    Optionally uses a simple partitioning scheme.
    &#34;&#34;&#34;
    if simple:
        partition_fn = partitionSimple
    else:
        partition_fn = partition

    _quickSort(arr, 0, len(arr) - 1, partition_fn, verbose)
    return arr</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.quick_sort.quickSortIterative"><code class="name flex">
<span>def <span class="ident">quickSortIterative</span></span>(<span>arr, simple=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quickSortIterative(arr, simple=False, verbose=False):
    # Choose the partition function based on the &#39;simple&#39; flag
    fn = partitionSimple if simple else partition

    # Stack for storing the start and end indices of the sub-arrays
    size = len(arr)
    stack = [(0, size - 1)]

    # Process each sub-array from the stack
    while stack:
        start, end = stack.pop()
        if start &lt; end:
            pivotIndex = fn(arr, start, end, verbose)

            # Push sub-arrays to the stack
            stack.append((start, pivotIndex - 1))
            stack.append((pivotIndex + 1, end))

    return arr</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cisc0503_dsa" href="index.html">cisc0503_dsa</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="cisc0503_dsa.quick_sort.formatDisplay" href="#cisc0503_dsa.quick_sort.formatDisplay">formatDisplay</a></code></li>
<li><code><a title="cisc0503_dsa.quick_sort.medianOfThree" href="#cisc0503_dsa.quick_sort.medianOfThree">medianOfThree</a></code></li>
<li><code><a title="cisc0503_dsa.quick_sort.partition" href="#cisc0503_dsa.quick_sort.partition">partition</a></code></li>
<li><code><a title="cisc0503_dsa.quick_sort.partitionSimple" href="#cisc0503_dsa.quick_sort.partitionSimple">partitionSimple</a></code></li>
<li><code><a title="cisc0503_dsa.quick_sort.quickSort" href="#cisc0503_dsa.quick_sort.quickSort">quickSort</a></code></li>
<li><code><a title="cisc0503_dsa.quick_sort.quickSortIterative" href="#cisc0503_dsa.quick_sort.quickSortIterative">quickSortIterative</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>