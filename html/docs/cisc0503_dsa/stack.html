<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cisc0503_dsa.stack API documentation</title>
<meta name="description" content="This module implements the Stack data structure â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cisc0503_dsa.stack</code></h1>
</header>
<section id="section-intro">
<p>This module implements the Stack data structure.</p>
<ul>
<li>
<p><code><a title="cisc0503_dsa.stack.Stack" href="#cisc0503_dsa.stack.Stack">Stack</a></code> implements a base class for an unbound stack with standard operations.</p>
</li>
<li>
<p><code><a title="cisc0503_dsa.stack.BoundStack" href="#cisc0503_dsa.stack.BoundStack">BoundStack</a></code> inherits from <code><a title="cisc0503_dsa.stack.Stack" href="#cisc0503_dsa.stack.Stack">Stack</a></code> to implement a bounded stack (i.e. with a maximum size).</p>
</li>
<li>
<p><code><a title="cisc0503_dsa.stack.ThresholdStack" href="#cisc0503_dsa.stack.ThresholdStack">ThresholdStack</a></code> also inherits from <code><a title="cisc0503_dsa.stack.Stack" href="#cisc0503_dsa.stack.Stack">Stack</a></code> to implement two stacks sharing a single array,
with a threshold parameter dividing the two stacks. Each stack can take up to the entire array,
with both of them sharing the same (bound) space, such that the sum of the sizes of the two
stacks is equal to the size of the array. We will call the stack at or below the threshold the
"lower" stack, and the stack above the threshold the "upper" stack.</p>
<p>Because we don't know <em>a priori</em> how big each stack will be, we can't simply divide the array
into two halves (or any other arbitrary length). But we can place the elements of the lower stack
at the beginning of the array (i.e. with its first element at index 0) and subsequent elements
at increasing indices. Then if we place the elements of the upper stack at the end of the array
(i.e. with its first element as the very last element of the array) and subsequent elements at
decreasing indices, we can keep track of the size of each stack by keeping track of two pointers.</p>
<p>The lower stack pointer is increased as items are pushed onto the stack, whereas the second stack
pointer is decreased as items are pushed onto the stack&ndash;i.e. it keeps track of the distance from
the end of the array.</p>
<p>Neither the push nor pop operations are affected by the size of the stacks or the array that holds
them. They only involve constant-time operations, so their time complexity is O(1).</p>
</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module implements the Stack data structure.

*   `Stack` implements a base class for an unbound stack with standard operations.

*   `BoundStack` inherits from `Stack` to implement a bounded stack (i.e. with a maximum size).

*   `ThresholdStack` also inherits from `Stack` to implement two stacks sharing a single array,
    with a threshold parameter dividing the two stacks. Each stack can take up to the entire array,
    with both of them sharing the same (bound) space, such that the sum of the sizes of the two
    stacks is equal to the size of the array. We will call the stack at or below the threshold the
    &#34;lower&#34; stack, and the stack above the threshold the &#34;upper&#34; stack.

    Because we don&#39;t know _a priori_ how big each stack will be, we can&#39;t simply divide the array
    into two halves (or any other arbitrary length). But we can place the elements of the lower stack
    at the beginning of the array (i.e. with its first element at index 0) and subsequent elements
    at increasing indices. Then if we place the elements of the upper stack at the end of the array
    (i.e. with its first element as the very last element of the array) and subsequent elements at
    decreasing indices, we can keep track of the size of each stack by keeping track of two pointers.

    The lower stack pointer is increased as items are pushed onto the stack, whereas the second stack
    pointer is decreased as items are pushed onto the stack--i.e. it keeps track of the distance from
    the end of the array.

    Neither the push nor pop operations are affected by the size of the stacks or the array that holds
    them. They only involve constant-time operations, so their time complexity is O(1).
&#34;&#34;&#34;

class Stack:
    &#34;&#34;&#34;
    Base class implementing an unbound stack with standard operations.

    &#34;&#34;&#34;
    _elements = []

    def __init__(self):
        self._size = -1
        self._elements = []

    def __repr__(self): # pragma: no cover
        return self.__str__()

    def __str__(self): # pragma: no cover
        &#34;&#34;&#34;
        Representation of the Stack object as a string
        
        For debugging purposes only, not used anywhere.

        Example in the Python shell:
        &gt;&gt;&gt; from stack import Stack
        &gt;&gt;&gt; s = Stack()
        &gt;&gt;&gt; s
        Stack[]
        &#34;&#34;&#34;
        return f&#34;{self.__class__.__name__}[{&#39; &#39;.join([str(i) for i in self._elements])}]&#34;

    @property
    def elements(self):
        raise Exception(&#34;Cannot access elements directly&#34;)

    def get_size(self):
        return len(self._elements)

    def __len__(self):
        # allows us to use len(stack) instead of stack.get_size()
        return self.get_size()

    def is_empty(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns True if the stack is empty, False otherwise.

        &#34;&#34;&#34;
        return self.get_size() == 0

    def push(self, item):
        &#34;&#34;&#34;
        Pushes an item onto the stack.

        args:
            item - the item to push onto the stack.

        &#34;&#34;&#34;
        self._elements.append(item)

    def pop(self) -&gt; any:
        &#34;&#34;&#34;
        Remove and return the top item on the stack.

        returns:
            any - the top item on the stack.
            None - if the stack is empty.
        &#34;&#34;&#34;
        if self.is_empty():
            return None
        return self._elements.pop()

    def peek(self) -&gt; any:
        &#34;&#34;&#34;
        Returns the _top item on the stack without removing it.

        returns:
            any - the _top item on the stack.
            None - if the stack is empty.
        &#34;&#34;&#34;
        if self.is_empty():
            return None
        return self._elements[-1]

    def is_full(self) -&gt; bool:
        &#34;&#34;&#34;
        An unbound stack is never full
        &#34;&#34;&#34;
        return False


class BoundStack(Stack):
    &#34;&#34;&#34;
    Bound stack with a maximum size.

    Here we keep track of the &#34;top&#34; of the stack rather than using native Python list methods.
    
    &#34;&#34;&#34;

    def __init__(self, size):
        if size &lt;= 0:
            raise Exception(f&#34;{self.__class__.__name__} requires a bounded size equal to a positive integer&#34;)
        self._size = size
        self._elements = [None] * size
        self._top = 0

    def get_size(self):
        return self._top

    def is_empty(self):
        return self._top == 0

    def is_full(self):
        return self.get_size() == self._size

    def push(self, item):
        &#34;&#34;&#34;
        Pushes an item onto the stack.

        args:
            item - the item to push onto the stack.

        &#34;&#34;&#34;
        if self.is_full():
            raise Exception(&#34;Stack is full&#34;)
        self._elements[self._top] = item
        self._top += 1

    def pop(self):
        &#34;&#34;&#34;
        Remove and return the top item on the stack.

        returns:
            any - the top item on the stack.
            None - if the stack is empty.
        &#34;&#34;&#34;
        if self.is_empty():
            return None
        self._top -= 1
        return self._elements[self._top]

    def peek(self):
        &#34;&#34;&#34;
        Returns the top item on the stack without removing it.

        returns:
            any - the _top item on the stack.
            None - if the stack is empty.
        &#34;&#34;&#34;
        if self.is_empty():
            return None
        return self._elements[self._top -1] # _top is one past the last element
    

class ThresholdStack(Stack):
    &#34;&#34;&#34;
    Two-way stack controlled by a _threshold which divides it into two.

    args:
        size - the maximum size of the stack. If not provided, the stack will be unbounded.
        threshold - the _threshold for the two stacks. If not provided, the _threshold will be 100.
    &#34;&#34;&#34;
    _threshold = 100

    def __init__(self, size, threshold):
        if size &lt;= 0:
            raise Exception(f&#34;{self.__class__.__name__} requires a bounded size equal to a positive integer&#34;)
        self._size = size
        self._elements = [None] * size
        self._threshold = threshold
        self._top = 0
        self._top2 = size - 1

    def is_full(self):
        &#34;&#34;&#34;
        Returns True if the stack is full, False otherwise.
        &#34;&#34;&#34;
        return self._top == (self._top2 + 1)

    def push(self, value):
        if self.is_full():
            raise Exception(&#34;Stack is full&#34;)
        if value &gt; self._threshold:
            self._top2 -= 1
            self._elements[self._top2] = value
        else:
            self._elements[self._top] = value
            self._top += 1

    def pop(self):
        raise NotImplementedError(&#34;Use pop1 or pop2 instead&#34;)

    def pop1(self):
        if self.is_empty1():
            return None
        self._top -= 1
        return self._elements[self._top]

    def pop2(self):
        if self.is_empty2():
            return None
        self._top2 += 1
        return self._elements[self._top2 - 1]

    def is_empty(self):
        &#34;&#34;&#34;Returns True if both stacks are empty, False otherwise&#34;&#34;&#34;
        return self.is_empty1() and self.is_empty2()

    def is_empty1(self):
        &#34;&#34;&#34;Returns True if the stack at/below the threshold is empty, False otherwise&#34;&#34;&#34;
        return self._top == 0

    def is_empty2(self):
        &#34;&#34;&#34;Returns True if the stack above the threshold is empty, False otherwise&#34;&#34;&#34;
        return self._top2 == self._size - 1

    def get_size(self):
        &#34;&#34;&#34;Total size of the stack&#34;&#34;&#34;
        return self.get_size1() + self.get_size2()

    def get_size1(self):
        &#34;&#34;&#34;Size of the stack at/below the threshold&#34;&#34;&#34;
        return self._top
    
    def get_size2(self):
        &#34;&#34;&#34;Size of the stack above the threshold&#34;&#34;&#34;
        return self._size - self._top2 - 1

class DoublePopStack(Stack):

    def pop(self):
        &#34;&#34;&#34;Pop two elements off the stack

        returns:
            (any, any) - the top two items on the stack.
            (any, None) - if the stack has only one element.
            (None, None) - if the stack is empty.
        &#34;&#34;&#34;
        return (super().pop(), super().pop())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cisc0503_dsa.stack.BoundStack"><code class="flex name class">
<span>class <span class="ident">BoundStack</span></span>
<span>(</span><span>size)</span>
</code></dt>
<dd>
<div class="desc"><p>Bound stack with a maximum size.</p>
<p>Here we keep track of the "top" of the stack rather than using native Python list methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoundStack(Stack):
    &#34;&#34;&#34;
    Bound stack with a maximum size.

    Here we keep track of the &#34;top&#34; of the stack rather than using native Python list methods.
    
    &#34;&#34;&#34;

    def __init__(self, size):
        if size &lt;= 0:
            raise Exception(f&#34;{self.__class__.__name__} requires a bounded size equal to a positive integer&#34;)
        self._size = size
        self._elements = [None] * size
        self._top = 0

    def get_size(self):
        return self._top

    def is_empty(self):
        return self._top == 0

    def is_full(self):
        return self.get_size() == self._size

    def push(self, item):
        &#34;&#34;&#34;
        Pushes an item onto the stack.

        args:
            item - the item to push onto the stack.

        &#34;&#34;&#34;
        if self.is_full():
            raise Exception(&#34;Stack is full&#34;)
        self._elements[self._top] = item
        self._top += 1

    def pop(self):
        &#34;&#34;&#34;
        Remove and return the top item on the stack.

        returns:
            any - the top item on the stack.
            None - if the stack is empty.
        &#34;&#34;&#34;
        if self.is_empty():
            return None
        self._top -= 1
        return self._elements[self._top]

    def peek(self):
        &#34;&#34;&#34;
        Returns the top item on the stack without removing it.

        returns:
            any - the _top item on the stack.
            None - if the stack is empty.
        &#34;&#34;&#34;
        if self.is_empty():
            return None
        return self._elements[self._top -1] # _top is one past the last element</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cisc0503_dsa.stack.Stack" href="#cisc0503_dsa.stack.Stack">Stack</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cisc0503_dsa.stack.BoundStack.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size(self):
    return self._top</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.BoundStack.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the top item on the stack without removing it.</p>
<p>returns:
any - the _top item on the stack.
None - if the stack is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek(self):
    &#34;&#34;&#34;
    Returns the top item on the stack without removing it.

    returns:
        any - the _top item on the stack.
        None - if the stack is empty.
    &#34;&#34;&#34;
    if self.is_empty():
        return None
    return self._elements[self._top -1] # _top is one past the last element</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cisc0503_dsa.stack.Stack" href="#cisc0503_dsa.stack.Stack">Stack</a></b></code>:
<ul class="hlist">
<li><code><a title="cisc0503_dsa.stack.Stack.is_empty" href="#cisc0503_dsa.stack.Stack.is_empty">is_empty</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.is_full" href="#cisc0503_dsa.stack.Stack.is_full">is_full</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.pop" href="#cisc0503_dsa.stack.Stack.pop">pop</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.push" href="#cisc0503_dsa.stack.Stack.push">push</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="cisc0503_dsa.stack.DoublePopStack"><code class="flex name class">
<span>class <span class="ident">DoublePopStack</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class implementing an unbound stack with standard operations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DoublePopStack(Stack):

    def pop(self):
        &#34;&#34;&#34;Pop two elements off the stack

        returns:
            (any, any) - the top two items on the stack.
            (any, None) - if the stack has only one element.
            (None, None) - if the stack is empty.
        &#34;&#34;&#34;
        return (super().pop(), super().pop())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cisc0503_dsa.stack.Stack" href="#cisc0503_dsa.stack.Stack">Stack</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cisc0503_dsa.stack.DoublePopStack.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Pop two elements off the stack</p>
<p>returns:
(any, any) - the top two items on the stack.
(any, None) - if the stack has only one element.
(None, None) - if the stack is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self):
    &#34;&#34;&#34;Pop two elements off the stack

    returns:
        (any, any) - the top two items on the stack.
        (any, None) - if the stack has only one element.
        (None, None) - if the stack is empty.
    &#34;&#34;&#34;
    return (super().pop(), super().pop())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cisc0503_dsa.stack.Stack" href="#cisc0503_dsa.stack.Stack">Stack</a></b></code>:
<ul class="hlist">
<li><code><a title="cisc0503_dsa.stack.Stack.is_empty" href="#cisc0503_dsa.stack.Stack.is_empty">is_empty</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.is_full" href="#cisc0503_dsa.stack.Stack.is_full">is_full</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.peek" href="#cisc0503_dsa.stack.Stack.peek">peek</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.push" href="#cisc0503_dsa.stack.Stack.push">push</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="cisc0503_dsa.stack.Stack"><code class="flex name class">
<span>class <span class="ident">Stack</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class implementing an unbound stack with standard operations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stack:
    &#34;&#34;&#34;
    Base class implementing an unbound stack with standard operations.

    &#34;&#34;&#34;
    _elements = []

    def __init__(self):
        self._size = -1
        self._elements = []

    def __repr__(self): # pragma: no cover
        return self.__str__()

    def __str__(self): # pragma: no cover
        &#34;&#34;&#34;
        Representation of the Stack object as a string
        
        For debugging purposes only, not used anywhere.

        Example in the Python shell:
        &gt;&gt;&gt; from stack import Stack
        &gt;&gt;&gt; s = Stack()
        &gt;&gt;&gt; s
        Stack[]
        &#34;&#34;&#34;
        return f&#34;{self.__class__.__name__}[{&#39; &#39;.join([str(i) for i in self._elements])}]&#34;

    @property
    def elements(self):
        raise Exception(&#34;Cannot access elements directly&#34;)

    def get_size(self):
        return len(self._elements)

    def __len__(self):
        # allows us to use len(stack) instead of stack.get_size()
        return self.get_size()

    def is_empty(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns True if the stack is empty, False otherwise.

        &#34;&#34;&#34;
        return self.get_size() == 0

    def push(self, item):
        &#34;&#34;&#34;
        Pushes an item onto the stack.

        args:
            item - the item to push onto the stack.

        &#34;&#34;&#34;
        self._elements.append(item)

    def pop(self) -&gt; any:
        &#34;&#34;&#34;
        Remove and return the top item on the stack.

        returns:
            any - the top item on the stack.
            None - if the stack is empty.
        &#34;&#34;&#34;
        if self.is_empty():
            return None
        return self._elements.pop()

    def peek(self) -&gt; any:
        &#34;&#34;&#34;
        Returns the _top item on the stack without removing it.

        returns:
            any - the _top item on the stack.
            None - if the stack is empty.
        &#34;&#34;&#34;
        if self.is_empty():
            return None
        return self._elements[-1]

    def is_full(self) -&gt; bool:
        &#34;&#34;&#34;
        An unbound stack is never full
        &#34;&#34;&#34;
        return False</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cisc0503_dsa.stack.BoundStack" href="#cisc0503_dsa.stack.BoundStack">BoundStack</a></li>
<li><a title="cisc0503_dsa.stack.DoublePopStack" href="#cisc0503_dsa.stack.DoublePopStack">DoublePopStack</a></li>
<li><a title="cisc0503_dsa.stack.ThresholdStack" href="#cisc0503_dsa.stack.ThresholdStack">ThresholdStack</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="cisc0503_dsa.stack.Stack.elements"><code class="name">var <span class="ident">elements</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def elements(self):
    raise Exception(&#34;Cannot access elements directly&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cisc0503_dsa.stack.Stack.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size(self):
    return len(self._elements)</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.Stack.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the stack is empty, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns True if the stack is empty, False otherwise.

    &#34;&#34;&#34;
    return self.get_size() == 0</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.Stack.is_full"><code class="name flex">
<span>def <span class="ident">is_full</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>An unbound stack is never full</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_full(self) -&gt; bool:
    &#34;&#34;&#34;
    An unbound stack is never full
    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.Stack.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self) â€‘>Â <built-inÂ functionÂ any></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the _top item on the stack without removing it.</p>
<p>returns:
any - the _top item on the stack.
None - if the stack is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek(self) -&gt; any:
    &#34;&#34;&#34;
    Returns the _top item on the stack without removing it.

    returns:
        any - the _top item on the stack.
        None - if the stack is empty.
    &#34;&#34;&#34;
    if self.is_empty():
        return None
    return self._elements[-1]</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.Stack.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self) â€‘>Â <built-inÂ functionÂ any></span>
</code></dt>
<dd>
<div class="desc"><p>Remove and return the top item on the stack.</p>
<p>returns:
any - the top item on the stack.
None - if the stack is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self) -&gt; any:
    &#34;&#34;&#34;
    Remove and return the top item on the stack.

    returns:
        any - the top item on the stack.
        None - if the stack is empty.
    &#34;&#34;&#34;
    if self.is_empty():
        return None
    return self._elements.pop()</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.Stack.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"><p>Pushes an item onto the stack.</p>
<p>args:
item - the item to push onto the stack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, item):
    &#34;&#34;&#34;
    Pushes an item onto the stack.

    args:
        item - the item to push onto the stack.

    &#34;&#34;&#34;
    self._elements.append(item)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cisc0503_dsa.stack.ThresholdStack"><code class="flex name class">
<span>class <span class="ident">ThresholdStack</span></span>
<span>(</span><span>size, threshold)</span>
</code></dt>
<dd>
<div class="desc"><p>Two-way stack controlled by a _threshold which divides it into two.</p>
<p>args:
size - the maximum size of the stack. If not provided, the stack will be unbounded.
threshold - the _threshold for the two stacks. If not provided, the _threshold will be 100.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThresholdStack(Stack):
    &#34;&#34;&#34;
    Two-way stack controlled by a _threshold which divides it into two.

    args:
        size - the maximum size of the stack. If not provided, the stack will be unbounded.
        threshold - the _threshold for the two stacks. If not provided, the _threshold will be 100.
    &#34;&#34;&#34;
    _threshold = 100

    def __init__(self, size, threshold):
        if size &lt;= 0:
            raise Exception(f&#34;{self.__class__.__name__} requires a bounded size equal to a positive integer&#34;)
        self._size = size
        self._elements = [None] * size
        self._threshold = threshold
        self._top = 0
        self._top2 = size - 1

    def is_full(self):
        &#34;&#34;&#34;
        Returns True if the stack is full, False otherwise.
        &#34;&#34;&#34;
        return self._top == (self._top2 + 1)

    def push(self, value):
        if self.is_full():
            raise Exception(&#34;Stack is full&#34;)
        if value &gt; self._threshold:
            self._top2 -= 1
            self._elements[self._top2] = value
        else:
            self._elements[self._top] = value
            self._top += 1

    def pop(self):
        raise NotImplementedError(&#34;Use pop1 or pop2 instead&#34;)

    def pop1(self):
        if self.is_empty1():
            return None
        self._top -= 1
        return self._elements[self._top]

    def pop2(self):
        if self.is_empty2():
            return None
        self._top2 += 1
        return self._elements[self._top2 - 1]

    def is_empty(self):
        &#34;&#34;&#34;Returns True if both stacks are empty, False otherwise&#34;&#34;&#34;
        return self.is_empty1() and self.is_empty2()

    def is_empty1(self):
        &#34;&#34;&#34;Returns True if the stack at/below the threshold is empty, False otherwise&#34;&#34;&#34;
        return self._top == 0

    def is_empty2(self):
        &#34;&#34;&#34;Returns True if the stack above the threshold is empty, False otherwise&#34;&#34;&#34;
        return self._top2 == self._size - 1

    def get_size(self):
        &#34;&#34;&#34;Total size of the stack&#34;&#34;&#34;
        return self.get_size1() + self.get_size2()

    def get_size1(self):
        &#34;&#34;&#34;Size of the stack at/below the threshold&#34;&#34;&#34;
        return self._top
    
    def get_size2(self):
        &#34;&#34;&#34;Size of the stack above the threshold&#34;&#34;&#34;
        return self._size - self._top2 - 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cisc0503_dsa.stack.Stack" href="#cisc0503_dsa.stack.Stack">Stack</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cisc0503_dsa.stack.ThresholdStack.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Total size of the stack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size(self):
    &#34;&#34;&#34;Total size of the stack&#34;&#34;&#34;
    return self.get_size1() + self.get_size2()</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.ThresholdStack.get_size1"><code class="name flex">
<span>def <span class="ident">get_size1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Size of the stack at/below the threshold</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size1(self):
    &#34;&#34;&#34;Size of the stack at/below the threshold&#34;&#34;&#34;
    return self._top</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.ThresholdStack.get_size2"><code class="name flex">
<span>def <span class="ident">get_size2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Size of the stack above the threshold</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size2(self):
    &#34;&#34;&#34;Size of the stack above the threshold&#34;&#34;&#34;
    return self._size - self._top2 - 1</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.ThresholdStack.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if both stacks are empty, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self):
    &#34;&#34;&#34;Returns True if both stacks are empty, False otherwise&#34;&#34;&#34;
    return self.is_empty1() and self.is_empty2()</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.ThresholdStack.is_empty1"><code class="name flex">
<span>def <span class="ident">is_empty1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the stack at/below the threshold is empty, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty1(self):
    &#34;&#34;&#34;Returns True if the stack at/below the threshold is empty, False otherwise&#34;&#34;&#34;
    return self._top == 0</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.ThresholdStack.is_empty2"><code class="name flex">
<span>def <span class="ident">is_empty2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the stack above the threshold is empty, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty2(self):
    &#34;&#34;&#34;Returns True if the stack above the threshold is empty, False otherwise&#34;&#34;&#34;
    return self._top2 == self._size - 1</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.ThresholdStack.is_full"><code class="name flex">
<span>def <span class="ident">is_full</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the stack is full, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_full(self):
    &#34;&#34;&#34;
    Returns True if the stack is full, False otherwise.
    &#34;&#34;&#34;
    return self._top == (self._top2 + 1)</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.ThresholdStack.pop1"><code class="name flex">
<span>def <span class="ident">pop1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop1(self):
    if self.is_empty1():
        return None
    self._top -= 1
    return self._elements[self._top]</code></pre>
</details>
</dd>
<dt id="cisc0503_dsa.stack.ThresholdStack.pop2"><code class="name flex">
<span>def <span class="ident">pop2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop2(self):
    if self.is_empty2():
        return None
    self._top2 += 1
    return self._elements[self._top2 - 1]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cisc0503_dsa.stack.Stack" href="#cisc0503_dsa.stack.Stack">Stack</a></b></code>:
<ul class="hlist">
<li><code><a title="cisc0503_dsa.stack.Stack.peek" href="#cisc0503_dsa.stack.Stack.peek">peek</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.pop" href="#cisc0503_dsa.stack.Stack.pop">pop</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.push" href="#cisc0503_dsa.stack.Stack.push">push</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cisc0503_dsa" href="index.html">cisc0503_dsa</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cisc0503_dsa.stack.BoundStack" href="#cisc0503_dsa.stack.BoundStack">BoundStack</a></code></h4>
<ul class="">
<li><code><a title="cisc0503_dsa.stack.BoundStack.get_size" href="#cisc0503_dsa.stack.BoundStack.get_size">get_size</a></code></li>
<li><code><a title="cisc0503_dsa.stack.BoundStack.peek" href="#cisc0503_dsa.stack.BoundStack.peek">peek</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cisc0503_dsa.stack.DoublePopStack" href="#cisc0503_dsa.stack.DoublePopStack">DoublePopStack</a></code></h4>
<ul class="">
<li><code><a title="cisc0503_dsa.stack.DoublePopStack.pop" href="#cisc0503_dsa.stack.DoublePopStack.pop">pop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cisc0503_dsa.stack.Stack" href="#cisc0503_dsa.stack.Stack">Stack</a></code></h4>
<ul class="two-column">
<li><code><a title="cisc0503_dsa.stack.Stack.elements" href="#cisc0503_dsa.stack.Stack.elements">elements</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.get_size" href="#cisc0503_dsa.stack.Stack.get_size">get_size</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.is_empty" href="#cisc0503_dsa.stack.Stack.is_empty">is_empty</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.is_full" href="#cisc0503_dsa.stack.Stack.is_full">is_full</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.peek" href="#cisc0503_dsa.stack.Stack.peek">peek</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.pop" href="#cisc0503_dsa.stack.Stack.pop">pop</a></code></li>
<li><code><a title="cisc0503_dsa.stack.Stack.push" href="#cisc0503_dsa.stack.Stack.push">push</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cisc0503_dsa.stack.ThresholdStack" href="#cisc0503_dsa.stack.ThresholdStack">ThresholdStack</a></code></h4>
<ul class="two-column">
<li><code><a title="cisc0503_dsa.stack.ThresholdStack.get_size" href="#cisc0503_dsa.stack.ThresholdStack.get_size">get_size</a></code></li>
<li><code><a title="cisc0503_dsa.stack.ThresholdStack.get_size1" href="#cisc0503_dsa.stack.ThresholdStack.get_size1">get_size1</a></code></li>
<li><code><a title="cisc0503_dsa.stack.ThresholdStack.get_size2" href="#cisc0503_dsa.stack.ThresholdStack.get_size2">get_size2</a></code></li>
<li><code><a title="cisc0503_dsa.stack.ThresholdStack.is_empty" href="#cisc0503_dsa.stack.ThresholdStack.is_empty">is_empty</a></code></li>
<li><code><a title="cisc0503_dsa.stack.ThresholdStack.is_empty1" href="#cisc0503_dsa.stack.ThresholdStack.is_empty1">is_empty1</a></code></li>
<li><code><a title="cisc0503_dsa.stack.ThresholdStack.is_empty2" href="#cisc0503_dsa.stack.ThresholdStack.is_empty2">is_empty2</a></code></li>
<li><code><a title="cisc0503_dsa.stack.ThresholdStack.is_full" href="#cisc0503_dsa.stack.ThresholdStack.is_full">is_full</a></code></li>
<li><code><a title="cisc0503_dsa.stack.ThresholdStack.pop1" href="#cisc0503_dsa.stack.ThresholdStack.pop1">pop1</a></code></li>
<li><code><a title="cisc0503_dsa.stack.ThresholdStack.pop2" href="#cisc0503_dsa.stack.ThresholdStack.pop2">pop2</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>